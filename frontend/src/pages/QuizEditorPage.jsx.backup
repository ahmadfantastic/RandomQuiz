import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Link, useNavigate, useParams } from 'react-router-dom';
import AppShell from '@/components/layout/AppShell';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Modal } from '@/components/ui/modal';
import api from '@/lib/api';
import { cn } from '@/lib/utils';
import { useResponseConfig } from '@/lib/useResponseConfig';
import { RESPONSE_TYPE_OPTIONS, getResponseTypeLabel } from '@/lib/responseTypes';
import QuizStatusBanner from '@/components/quiz-editor/QuizStatusBanner';
import QuizOverviewTab from '@/components/quiz-editor/QuizOverviewTab';
import QuizSlotsTab from '@/components/quiz-editor/QuizSlotsTab';
import QuizResponsesTab from '@/components/quiz-editor/QuizResponsesTab';
import QuizAllowedInstructorsTab from '@/components/quiz-editor/QuizAllowedInstructorsTab';

const TABS = {
  OVERVIEW: 'overview',
  SLOTS: 'slots',
  RESPONSES: 'responses',
  INSTRUCTORS: 'instructors',
};

const padTime = (value) => String(value).padStart(2, '0');

const defaultSlotForm = { label: '', problem_bank: '', response_type: 'open_text' };

const toInputValue = (value) => {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return '';
  return `${date.getFullYear()}-${padTime(date.getMonth() + 1)}-${padTime(date.getDate())}T${padTime(date.getHours())}:${padTime(date.getMinutes())}`;
};

const toIsoString = (value) => {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString();
};

const formatDateTime = (value) => {
  if (!value) return 'Not scheduled';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return 'Not scheduled';
  return date.toLocaleString(undefined, {
    dateStyle: 'medium',
    timeStyle: 'short',
  });
};

const normalizeSlot = (slot) => ({
  ...slot,
  response_type: slot.response_type || 'open_text',
  order: typeof slot.order === 'number' ? slot.order.toString() : slot.order || '',
  slot_problems: Array.isArray(slot.slot_problems) ? slot.slot_problems : [],
  original_problem_bank: slot.problem_bank ?? null,
  pending_bank_change: false,
});

const QuizEditorPage = () => {
  const { quizId } = useParams();
  const quizIdNumber = Number(quizId);
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState(TABS.OVERVIEW);
  const [quiz, setQuiz] = useState(null);
  const [quizzes, setQuizzes] = useState([]);
  const [isLoadingQuiz, setIsLoadingQuiz] = useState(true);
  const [isLoadingQuizzes, setIsLoadingQuizzes] = useState(true);
  const [banks, setBanks] = useState([]);
  const [isLoadingBanks, setIsLoadingBanks] = useState(true);
  const [slots, setSlots] = useState([]);
  const [attempts, setAttempts] = useState([]);
  const [details, setDetails] = useState({ title: '', description: '', start_time: '', end_time: '' });
  const [isSchedulingEnabled, setIsSchedulingEnabled] = useState(false);
  const [detailsSaving, setDetailsSaving] = useState(false);
  const [detailsError, setDetailsError] = useState('');
  const [pageError, setPageError] = useState('');
  const [slotForm, setSlotForm] = useState(() => ({ ...defaultSlotForm }));
  const [slotFormError, setSlotFormError] = useState('');
  const [isCreatingSlot, setIsCreatingSlot] = useState(false);
  const [slotError, setSlotError] = useState('');
  const [savingSlotId, setSavingSlotId] = useState(null);
  const [slotProblemOptions, setSlotProblemOptions] = useState({});
  const [attemptError, setAttemptError] = useState('');
  const [attemptToDelete, setAttemptToDelete] = useState(null);
  const [isDeletingAttempt, setIsDeletingAttempt] = useState(false);
  const [copyMessage, setCopyMessage] = useState('');
  const [isSlotModalOpen, setIsSlotModalOpen] = useState(false);
  const [activeSlotId, setActiveSlotId] = useState(null);
  const [selectedAttempt, setSelectedAttempt] = useState(null);
  const [allowedInstructors, setAllowedInstructors] = useState([]);
  const [instructorId, setInstructorId] = useState('');
  const [instructorError, setInstructorError] = useState('');
  const pendingBankRequests = useRef(new Set());
  const { config: responseConfig } = useResponseConfig();

  const ratingCriteria = useMemo(() => {
    return Array.isArray(responseConfig?.criteria) ? responseConfig.criteria : [];
  }, [responseConfig]);

  const ratingScaleLabelMap = useMemo(() => {
    if (!Array.isArray(responseConfig?.scale)) {
      return {};
    }
    return responseConfig.scale.reduce((acc, option) => {
      acc[`${option.value}`] = option.label;
      return acc;
    }, {});
  }, [responseConfig]);

  const openSlotModal = () => {
    setSlotForm({ ...defaultSlotForm });
    setSlotFormError('');
    setIsSlotModalOpen(true);
  };

  const closeSlotModal = () => {
    setIsSlotModalOpen(false);
    setSlotForm({ ...defaultSlotForm });
    setSlotFormError('');
  };

  const openSlotDetailModal = (slotId) => {
    setSlotError('');
    setActiveSlotId(slotId);
  };

  const closeSlotDetailModal = () => {
    setActiveSlotId(null);
  };

  const openAttemptModal = (attempt) => {
    setSelectedAttempt(attempt);
  };

  const closeAttemptModal = () => {
    setSelectedAttempt(null);
  };

  const loadBankProblems = useCallback(
    (bankId) => {
      if (!bankId || slotProblemOptions[bankId] || pendingBankRequests.current.has(bankId)) {
        return;
      }
      pendingBankRequests.current.add(bankId);
      api
        .get(`/api/problem-banks/${bankId}/problems/`)
        .then((res) => {
          setSlotProblemOptions((prev) => ({ ...prev, [bankId]: res.data }));
          setSlotError('');
        })
        .catch(() => {
          setSlotError('Unable to load the problems for one of the banks.');
        })
        .finally(() => {
          pendingBankRequests.current.delete(bankId);
        });
    },
    [slotProblemOptions]
  );

  const loadQuizList = () => {
    setIsLoadingQuizzes(true);
    api
      .get('/api/quizzes/')
      .then((res) => setQuizzes(res.data))
      .catch(() => {})
      .finally(() => setIsLoadingQuizzes(false));
  };

  const loadBanks = () => {
    setIsLoadingBanks(true);
    api
      .get('/api/problem-banks/')
      .then((res) => setBanks(res.data))
      .catch(() => setBanks([]))
      .finally(() => setIsLoadingBanks(false));
  };

  const loadAttempts = () => {
    return api
      .get(`/api/quizzes/${quizId}/attempts/`)
      .then((res) => {
        setAttempts(res.data);
        setAttemptError('');
      })
      .catch(() => setAttemptError('Unable to load student responses.'));
  };

  const requestAttemptDeletion = (attempt) => {
    setAttemptToDelete(attempt);
    setAttemptError('');
  };

  const closeAttemptDeleteModal = () => {
    if (isDeletingAttempt) return;
    setAttemptToDelete(null);
  };

  const handleDeleteAttempt = async () => {
    if (!attemptToDelete) return;
    setIsDeletingAttempt(true);
    try {
      await api.delete(`/api/quizzes/${quizId}/attempts/${attemptToDelete.id}/`);
      setAttemptError('');
      setAttemptToDelete(null);
      await loadAttempts();
    } catch (error) {
      const detail = error.response?.data?.detail || 'Unable to delete this attempt right now.';
      setAttemptError(detail);
    } finally {
      setIsDeletingAttempt(false);
    }
  };

  const loadSlots = () => {
    api
      .get(`/api/quizzes/${quizId}/slots/`)
      .then((res) => {
        setSlots(res.data.map(normalizeSlot));
        setSlotError('');
      })
      .catch(() => setSlotError('Unable to load slots right now.'));
  };

  const loadAllowedInstructors = () => {
    api
      .get(`/api/quizzes/${quizId}/allowed-instructors/`)
      .then((res) => {
        setAllowedInstructors(res.data);
        setInstructorError('');
      })
      .catch(() => setInstructorError('Unable to load allowed instructors.'));
  };

  const handleAddInstructor = async () => {
    if (!instructorId.trim()) return;
    try {
      await api.post(`/api/quizzes/${quizId}/allowed-instructors/`, { instructor_id: instructorId });
      setInstructorId('');
      setInstructorError('');
      loadAllowedInstructors();
    } catch (error) {
      const detail = error.response?.data?.detail || 'Unable to add instructor.';
      setInstructorError(detail);
    }
  };

  const handleRemoveInstructor = async (id) => {
    try {
      await api.delete(`/api/quizzes/${quizId}/allowed-instructors/${id}/`);
      setInstructorError('');
      loadAllowedInstructors();
    } catch (error) {
      const detail = error.response?.data?.detail || 'Unable to remove instructor.';
      setInstructorError(detail);
    }
  };

  const loadQuizData = () => {
    setIsLoadingQuiz(true);
    Promise.all([
      api.get(`/api/quizzes/${quizId}/`),
      api.get(`/api/quizzes/${quizId}/slots/`),
      api.get(`/api/quizzes/${quizId}/attempts/`),
    ])
      .then(([quizRes, slotsRes, attemptsRes]) => {
        setQuiz(quizRes.data);
        setDetails({
          title: quizRes.data.title || '',
          description: quizRes.data.description || '',
          start_time: toInputValue(quizRes.data.start_time),
          end_time: toInputValue(quizRes.data.end_time),
        });
        setIsSchedulingEnabled(Boolean(quizRes.data.start_time));
        setSlots(slotsRes.data.map(normalizeSlot));
        setAttempts(attemptsRes.data);
        setPageError('');
      })
      .catch((error) => {
        if (error?.response?.status === 404) {
          navigate('/dashboard', { replace: true });
          return;
        }
        setPageError('Unable to load quiz details. Please refresh the page.');
      })
      .finally(() => setIsLoadingQuiz(false));
  };

  useEffect(() => {
    loadBanks();
  }, []);

  useEffect(() => {
    loadQuizList();
  }, [quizId]);

  useEffect(() => {
    setSlotProblemOptions({});
    pendingBankRequests.current.clear();
    loadQuizData();
    loadAllowedInstructors();
  }, [quizId]);

  useEffect(() => {
    slots.forEach((slot) => {
      loadBankProblems(slot.problem_bank);
    });
  }, [slots, loadBankProblems]);

  useEffect(() => {
    if (!isSlotModalOpen) return undefined;
    const handleKeyDown = (event) => {
      if (event.key === 'Escape') {
        closeSlotModal();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isSlotModalOpen]);

  const endBeforeStart = useMemo(() => {
    if (!isSchedulingEnabled || !details.start_time || !details.end_time) return false;
    const start = new Date(details.start_time);
    const end = new Date(details.end_time);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) return false;
    return end <= start;
  }, [isSchedulingEnabled, details.start_time, details.end_time]);

  const slotReadiness = useMemo(() => {
    const total = slots.length;
    const ready = slots.filter((slot) => slot.slot_problems?.length).length;
    return { ready, total };
  }, [slots]);

  const schedulePreview = useMemo(() => {
    if (!quiz) return { status: 'Draft', description: 'Add problem slots to get this quiz ready.' };
    const now = Date.now();
    const start = quiz.start_time ? new Date(quiz.start_time).getTime() : null;
    const end = quiz.end_time ? new Date(quiz.end_time).getTime() : null;
    if (start && now < start) {
      return { status: 'Scheduled', description: `Opens ${formatDateTime(quiz.start_time)}` };
    }
    if (end && now > end) {
      return { status: 'Closed', description: `Closed ${formatDateTime(quiz.end_time)}` };
    }
    if (start && (!end || now <= end)) {
      return { status: 'Open', description: 'Students can join using the public link below.' };
    }
    return { status: 'Draft', description: 'Share the public link whenever you are ready.' };
  }, [quiz]);

  const handleDetailChange = (event) => {
    const { name, value } = event.target;
    setDetails((prev) => ({ ...prev, [name]: value }));
    setDetailsError('');
  };

  const handleSaveDetails = async (event) => {
    event.preventDefault();
    if (!quiz) return;
    if (!details.title.trim()) {
      setDetailsError('Quiz title is required.');
      return;
    }
    if (isSchedulingEnabled && !details.start_time) {
      setDetailsError('Select a start time to enable scheduling.');
      return;
    }
    if (endBeforeStart) {
      setDetailsError('The end time must be after the start time.');
      return;
    }
    setDetailsSaving(true);
    try {
      const payload = {
        title: details.title.trim(),
        description: details.description.trim(),
      };
      if (isSchedulingEnabled) {
        const startIso = toIsoString(details.start_time);
        const endIso = toIsoString(details.end_time);
        if (startIso) payload.start_time = startIso;
        payload.end_time = endIso;
      } else {
        payload.start_time = null;
        payload.end_time = null;
      }
      const response = await api.patch(`/api/quizzes/${quiz.id}/`, payload);
      setQuiz(response.data);
      setDetailsError('');
    } catch (error) {
      const data = error.response?.data;
      const detail = data?.detail || data?.title?.[0] || data?.start_time?.[0] || 'Could not save the quiz details.';
      setDetailsError(detail);
    } finally {
      setDetailsSaving(false);
    }
  };

  const handleSlotFormChange = (event) => {
    const { name, value } = event.target;
    setSlotForm((prev) => ({ ...prev, [name]: value }));
    setSlotFormError('');
  };

  const handleCreateSlot = async (event) => {
    event.preventDefault();
    if (!slotForm.label.trim()) {
      setSlotFormError('Provide a label for the slot.');
      return;
    }
    if (!slotForm.problem_bank) {
      setSlotFormError('Select a problem bank for this slot.');
      return;
    }
    setIsCreatingSlot(true);
    try {
      const payload = {
        label: slotForm.label.trim(),
        problem_bank: Number(slotForm.problem_bank),
        response_type: slotForm.response_type,
      };
      await api.post(`/api/quizzes/${quizId}/slots/`, payload);
      closeSlotModal();
      loadSlots();
    } catch (error) {
      const detail = error.response?.data?.detail || error.response?.data?.order?.[0] || 'Could not add the slot yet.';
      setSlotFormError(detail);
    } finally {
      setIsCreatingSlot(false);
    }
  };

  const handleSlotChange = (slotId, field, value) => {
    if (field === 'problem_bank' && (value === '' || value === null)) {
      setSlotError('Each slot must stay linked to a problem bank.');
      return;
    }
    setSlots((prev) =>
      prev.map((slot) => {
        if (slot.id !== slotId) {
          return slot;
        }
        if (field === 'problem_bank') {
          const normalizedValue = Number(value);
          const shouldReset = normalizedValue !== slot.problem_bank;
          const selectedBank = normalizedValue ? banks.find((bank) => bank.id === normalizedValue) : null;
          return {
            ...slot,
            problem_bank: normalizedValue,
            problem_bank_name: selectedBank ? selectedBank.name : null,
            pending_bank_change: normalizedValue !== slot.original_problem_bank,
            ...(shouldReset ? { slot_problems: [] } : {}),
          };
        }
        return {
          ...slot,
          [field]: value,
        };
      })
    );
    if (field === 'problem_bank') {
      const normalizedValue = Number(value);
      if (normalizedValue) {
        loadBankProblems(normalizedValue);
      }
      setSlotError('');
    }
  };

  const handleSaveSlot = async (slot) => {
    if (!slot.label.trim()) {
      setSlotError('Slot label cannot be empty.');
      return;
    }
    const selectedBankId = Number(slot.problem_bank);
    if (!selectedBankId) {
      setSlotError('Each slot must have a problem bank.');
      return;
    }
    setSavingSlotId(slot.id);
    setSlotError('');
    try {
      await api.patch(`/api/slots/${slot.id}/`, {
        label: slot.label.trim(),
        problem_bank: selectedBankId,
        response_type: slot.response_type,
      });
      loadSlots();
    } catch (error) {
      const detail = error.response?.data?.detail || error.response?.data?.label?.[0] || 'Unable to update the slot.';
      setSlotError(detail);
    } finally {
      setSavingSlotId(null);
    }
  };

  const toggleSlotProblem = async (slot, problem) => {
    if (!slot.problem_bank) {
      setSlotError('Assign a problem bank to the slot before choosing problems.');
      return;
    }
    if (slot.pending_bank_change) {
      setSlotError('Save the slot after changing its bank before selecting problems.');
      return;
    }
    const existing = slot.slot_problems.find((sp) => sp.problem === problem.id);
    try {
      if (existing) {
        await api.delete(`/api/slot-problems/${existing.id}/`);
      } else {
        await api.post(`/api/slots/${slot.id}/slot-problems/`, { problem_ids: [problem.id] });
      }
      loadSlots();
    } catch {
      setSlotError('Unable to update the problem selection right now.');
    }
  };

  const handleCopyLink = async () => {
    if (!quiz) return;
    const base = typeof window !== 'undefined' ? window.location.origin : '';
    const link = `${base}/q/${quiz.public_id}`;
    try {
      await navigator.clipboard.writeText(link);
      setCopyMessage('Copied link to clipboard');
    } catch {
      setCopyMessage('Unable to copy link.');
    }
  };

  useEffect(() => {
    if (!copyMessage) return undefined;
    const timeout = setTimeout(() => setCopyMessage(''), 2500);
    return () => clearTimeout(timeout);
  }, [copyMessage]);

  const quizLink = quiz ? `/q/${quiz.public_id}` : '';
  const canCreateSlot = Boolean(slotForm.label.trim() && slotForm.problem_bank);
  const readyForStudents = slotReadiness.total > 0 && slotReadiness.ready === slotReadiness.total;
  const activeSlot = useMemo(() => {
    if (activeSlotId === null) {
      return null;
    }
    return slots.find((slot) => slot.id === activeSlotId) || null;
  }, [activeSlotId, slots]);

  const renderSlotProblems = (slot) => {
    if (!slot.problem_bank) {
      return <p className="text-sm text-muted-foreground">Select a problem bank above to enable this slot.</p>;
    }
    const problems = slotProblemOptions[slot.problem_bank];
    if (!problems) {
      return <p className="text-sm text-muted-foreground">Loading the problems for this bank‚Ä¶</p>;
    }
    if (!problems.length) {
      return <p className="text-sm text-muted-foreground">No problems in this bank yet. Add them from the problem bank manager.</p>;
    }
    const disableChanges = Boolean(slot.pending_bank_change);
    return (
      <div className="space-y-3">
        {disableChanges && (
          <p className="text-sm text-muted-foreground">Save this slot to confirm the bank before selecting problems.</p>
        )}
        {problems.map((problem) => {
          const linked = slot.slot_problems.find((sp) => sp.problem === problem.id);
          return (
            <label key={problem.id} className="flex cursor-pointer items-start gap-3 rounded-lg border p-3">
              <input
                type="checkbox"
                className="mt-1"
                checked={Boolean(linked)}
                disabled={disableChanges}
                onChange={() => toggleSlotProblem(slot, problem)}
              />
              <div>
                <p className="text-sm font-medium">
                  {problem.display_label}
                  <span className="text-muted-foreground"> ¬∑ </span>
                  <span className="text-muted-foreground">Order {problem.order_in_bank}</span>
                </p>
                <p className="text-sm text-muted-foreground">{problem.statement}</p>
              </div>
            </label>
          );
        })}
      </div>
    );
  };

  const attemptsSummary = useMemo(() => {
    const total = attempts.length;
    const completed = attempts.filter((attempt) => Boolean(attempt.completed_at)).length;
    return { total, completed };
  }, [attempts]);

  const renderAttemptAnswer = (attemptSlot) => {
    if (attemptSlot.response_type === 'rating') {
      const ratings = attemptSlot.answer_data?.ratings;
      if (!ratings || typeof ratings !== 'object' || !Object.keys(ratings).length) {
        return <span className="text-muted-foreground">No rating submitted.</span>;
      }
      const rows = (ratingCriteria.length
        ? ratingCriteria.map((criterion) => ({
            id: criterion.id,
            name: criterion.name,
            description: criterion.description,
            value: ratings[criterion.id],
          }))
        : Object.entries(ratings).map(([id, value]) => ({ id, name: id, description: '', value }))
      ).filter((row) => row.id);
      if (!rows.length) {
        return <span className="text-muted-foreground">No rating submitted.</span>;
      }
      return (
        <div className="space-y-2">
          {rows.map((row) => {
            const valueKey = `${row.value}`;
            const scaleLabel = valueKey && ratingScaleLabelMap[valueKey] ? ratingScaleLabelMap[valueKey] : null;
            const displayValue =
              row.value === undefined || row.value === null
                ? '‚Äî'
                : scaleLabel
                ? `${scaleLabel} (${row.value})`
                : row.value;
            return (
              <div key={row.id} className="flex flex-wrap items-center justify-between gap-3 rounded-md border px-3 py-2 text-sm">
                <div>
                  <p className="font-semibold">{row.name}</p>
                  {row.description && <p className="text-xs text-muted-foreground">{row.description}</p>}
                </div>
                <p className="font-medium text-foreground">{displayValue}</p>
              </div>
            );
          })}
        </div>
      );
    }
    const text = (attemptSlot.answer_data?.text || '').trim();
    if (!text) {
      return <span className="text-muted-foreground">No answer submitted.</span>;
    }
    return <p className="whitespace-pre-wrap">{text}</p>;
  };

  return (
    <AppShell
      title={quiz ? quiz.title : 'Quiz workspace'}
      description="Configure quiz settings, manage problem slots, and review student responses."
      actions={
        <>
          <Button variant="outline" to="/dashboard">
            Dashboard
          </Button>
          {quiz && (
            <Button to={quizLink} target="_blank" rel="noreferrer">
              Preview
            </Button>
          )}
        </>
      }
    >
      {isLoadingQuiz ? (
        <div className="space-y-4">
          <div className="h-24 animate-pulse rounded-xl bg-muted" />
          <div className="h-24 animate-pulse rounded-xl bg-muted" />
          <div className="h-24 animate-pulse rounded-xl bg-muted" />
        </div>
      ) : !quiz ? (
        <Card className="border-destructive/30 bg-destructive/5">
          <CardContent className="py-8 text-center text-destructive">
            <p className="text-lg font-semibold">Quiz not found</p>
            <p className="text-sm">This quiz may have been deleted or you don't have access.</p>
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-6">
          {pageError && (
            <Card className="border-destructive/30 bg-destructive/5">
              <CardContent className="py-4 text-sm text-destructive">{pageError}</CardContent>
            </Card>
          )}

          {/* Status Banner */}
          <QuizStatusBanner
            readyForStudents={readyForStudents}
            schedulePreview={schedulePreview}
            slotReadiness={slotReadiness}
            attemptsSummary={attemptsSummary}
            handleCopyLink={handleCopyLink}
            copyMessage={copyMessage}
          />

          {/* Tab Navigation */}
          <div className="border-b">
            <nav className="flex gap-6">
              {[
                { id: TABS.OVERVIEW, label: 'Overview', icon: 'üìã' },
                { id: TABS.SLOTS, label: 'Problem Slots', icon: 'üé≤', badge: slotReadiness.total },
                { id: TABS.RESPONSES, label: 'Responses', icon: 'üìù', badge: attempts.length },
                { id: TABS.INSTRUCTORS, label: 'Instructors', icon: 'üë•', badge: allowedInstructors.length },
              ].map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={cn(
                    'flex items-center gap-2 border-b-2 px-4 py-3 text-sm font-medium transition-colors',
                    activeTab === tab.id
                      ? 'border-primary text-primary'
                      : 'border-transparent text-muted-foreground hover:text-foreground'
                  )}
                >
                  <span>{tab.icon}</span>
                  <span>{tab.label}</span>
                  {tab.badge !== undefined && (
                    <span className="ml-1 rounded-full bg-muted px-2 py-0.5 text-xs">
                      {tab.badge}
                    </span>
                  )}
                </button>
              ))}
            </nav>
          </div>

          {/* Tab Content */}
          <div className="min-h-[400px]">
            {activeTab === TABS.OVERVIEW && (
              <div className="grid gap-6 lg:grid-cols-2">
                <Card>
                  <CardHeader>
                    <CardTitle>Quiz Details</CardTitle>
                    <CardDescription>Basic information displayed to students and instructors</CardDescription>
                  </CardHeader>
                  <CardContent>
                    <form className="space-y-4" onSubmit={handleSaveDetails}>
                      <div className="space-y-2">
                        <Label htmlFor="quiz-title">Title</Label>
                        <Input 
                          id="quiz-title" 
                          name="title" 
                          value={details.title} 
                          onChange={handleDetailChange} 
                          maxLength={120} 
                          required 
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="quiz-description">Description</Label>
                        <Textarea
                          id="quiz-description"
                          name="description"
                          value={details.description}
                          onChange={handleDetailChange}
                          rows={3}
                          maxLength={500}
                        />
                      </div>
                      {detailsError && <p className="text-sm text-destructive">{detailsError}</p>}
                      <Button type="submit" disabled={detailsSaving} className="w-full">
                        {detailsSaving ? 'Saving...' : 'Save Changes'}
                      </Button>
                    </form>
                  </CardContent>
                </Card>

                <Card>
                  <CardHeader>
                    <CardTitle>Schedule</CardTitle>
                    <CardDescription>Control when students can access this quiz</CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <label className="flex items-center justify-between rounded-lg border p-3">
                      <span className="text-sm font-medium">Enable scheduling</span>
                      <button
                        type="button"
                        className={cn(
                          'relative inline-flex h-6 w-11 items-center rounded-full transition-colors',
                          isSchedulingEnabled ? 'bg-primary' : 'bg-muted'
                        )}
                        role="switch"
                        aria-checked={isSchedulingEnabled}
                        onClick={() => {
                          setIsSchedulingEnabled((value) => !value);
                          if (isSchedulingEnabled) {
                            setDetails((prev) => ({ ...prev, start_time: '', end_time: '' }));
                          }
                        }}
                      >
                        <span
                          className={cn(
                            'inline-block h-5 w-5 transform rounded-full bg-white shadow transition-transform',
                            isSchedulingEnabled ? 'translate-x-5' : 'translate-x-1'
                          )}
                        />
                      </button>
                    </label>
                    <div className="grid gap-3 md:grid-cols-2">
                      <div className="space-y-2">
                        <Label htmlFor="quiz-start">Start time</Label>
                        <Input
                          id="quiz-start"
                          type="datetime-local"
                          name="start_time"
                          value={details.start_time}
                          onChange={handleDetailChange}
                          disabled={!isSchedulingEnabled}
                        />
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor="quiz-end">End time</Label>
                        <Input
                          id="quiz-end"
                          type="datetime-local"
                          name="end_time"
                          value={details.end_time}
                          onChange={handleDetailChange}
                          disabled={!isSchedulingEnabled}
                        />
                      </div>
                    </div>
                    {endBeforeStart && (
                      <p className="text-sm text-destructive">End time must be after start time</p>
                    )}
                  </CardContent>
                </Card>

                <Card className="lg:col-span-2">
                  <CardHeader>
                    <CardTitle>Public Access Link</CardTitle>
                    <CardDescription>Share this link with students to start collecting responses</CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center gap-3">
                      <Input value={quizLink} readOnly className="font-mono text-sm" />
                      <Button onClick={handleCopyLink}>Copy</Button>
                      <Button variant="outline" to={quizLink} target="_blank" rel="noreferrer">
                        Open
                      </Button>
                    </div>
                    {!readyForStudents && (
                      <p className="mt-3 text-sm text-amber-600">
                        ‚ö†Ô∏è Configure at least one slot with problems before sharing
                      </p>
                    )}
                  </CardContent>
                </Card>
              </div>
            )}

            {activeTab === TABS.SLOTS && (
              <div className="space-y-6">
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="text-lg font-semibold">Problem Slots</h3>
                    <p className="text-sm text-muted-foreground">
                      Each slot draws random problems from a bank
                    </p>
                  </div>
                  <div className="flex gap-2">
                    <Button variant="outline" onClick={loadSlots}>Refresh</Button>
                    <Button variant="outline" to="/problem-banks">Manage Banks</Button>
                    <Button onClick={openSlotModal} disabled={isLoadingBanks || !banks.length}>
                      Add Slot
                    </Button>
                  </div>
                </div>

                {slotError && (
                  <Card className="border-destructive/30 bg-destructive/5">
                    <CardContent className="py-3 text-sm text-destructive">{slotError}</CardContent>
                  </Card>
                )}

                {!slots.length ? (
                  <Card>
                    <CardContent className="py-12 text-center">
                      <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-muted">
                        <svg className="h-8 w-8 text-muted-foreground" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                        </svg>
                      </div>
                      <p className="text-lg font-semibold">No slots yet</p>
                      <p className="text-sm text-muted-foreground">Create your first slot to start building the quiz</p>
                      <Button onClick={openSlotModal} className="mt-4" disabled={isLoadingBanks || !banks.length}>
                        Add Your First Slot
                      </Button>
                    </CardContent>
                  </Card>
                ) : (
                  <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                    {slots.map((slot) => {
                      const problemCount = slot.slot_problems?.length ?? 0;
                      const isReady = problemCount > 0;
                      return (
                        <Card key={slot.id} className={cn(
                          'transition-all hover:shadow-md',
                          isReady ? 'border-emerald-500/20' : 'border-amber-500/20'
                        )}>
                          <CardHeader className="pb-3">
                            <div className="flex items-start justify-between gap-2">
                              <div className="flex-1">
                                <CardTitle className="text-base">{slot.label || 'Untitled'}</CardTitle>
                                <p className="text-xs text-muted-foreground">Order {slot.order || '‚Äî'}</p>
                              </div>
                              <span
                                className={cn(
                                  'rounded-full px-2 py-1 text-xs font-semibold',
                                  isReady ? 'bg-emerald-100 text-emerald-800' : 'bg-amber-100 text-amber-800'
                                )}
                              >
                                {isReady ? 'Ready' : 'Setup'}
                              </span>
                            </div>
                          </CardHeader>
                          <CardContent className="space-y-3">
                            <div className="space-y-1 text-sm">
                              <div className="flex justify-between">
                                <span className="text-muted-foreground">Bank:</span>
                                <span className="font-medium">{slot.problem_bank_name || 'None'}</span>
                              </div>
                              <div className="flex justify-between">
                                <span className="text-muted-foreground">Response:</span>
                                <span className="font-medium">{getResponseTypeLabel(slot.response_type)}</span>
                              </div>
                              <div className="flex justify-between">
                                <span className="text-muted-foreground">Problems:</span>
                                <span className="font-medium">{problemCount}</span>
                              </div>
                            </div>
                            <Button 
                              onClick={() => openSlotDetailModal(slot.id)} 
                              size="sm" 
                              className="w-full"
                              variant={isReady ? 'outline' : 'default'}
                            >
                              {isReady ? 'Edit Slot' : 'Configure Slot'}
                            </Button>
                          </CardContent>
                        </Card>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {activeTab === TABS.RESPONSES && (
              <div className="space-y-6">
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="text-lg font-semibold">Student Responses</h3>
                    <p className="text-sm text-muted-foreground">
                      View and manage all student attempts
                    </p>
                  </div>
                  <Button variant="outline" onClick={loadAttempts}>Refresh</Button>
                </div>

                {attemptError && (
                  <Card className="border-destructive/30 bg-destructive/5">
                    <CardContent className="py-3 text-sm text-destructive">{attemptError}</CardContent>
                  </Card>
                )}

                {!attempts.length ? (
                  <Card>
                    <CardContent className="py-12 text-center">
                      <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-muted">
                        <svg className="h-8 w-8 text-muted-foreground" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                      </div>
                      <p className="text-lg font-semibold">No responses yet</p>
                      <p className="text-sm text-muted-foreground">Responses will appear here once students start the quiz</p>
                    </CardContent>
                  </Card>
                ) : (
                  <div className="space-y-3">
                    {attempts.map((attempt) => {
                      const isCompleted = Boolean(attempt.completed_at);
                      const answerCount = attempt.attempt_slots?.length || 0;
                      return (
                        <Card key={attempt.id} className="hover:shadow-md transition-shadow">
                          <CardContent className="p-2">
                            <div className="flex items-center justify-between gap-4">
                              <div className="flex items-center gap-4">
                                <div className={cn(
                                  'flex h-10 w-10 items-center justify-center rounded-full',
                                  isCompleted ? 'bg-emerald-100 text-emerald-600' : 'bg-slate-100 text-slate-600'
                                )}>
                                  {isCompleted ? (
                                    <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                                    </svg>
                                  ) : (
                                    <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                  )}
                                </div>
                                <div>
                                  <p className="font-semibold">{attempt.student_identifier || 'Unknown'}</p>
                                  <p className="text-sm text-muted-foreground">
                                    Started {formatDateTime(attempt.started_at)}
                                    {isCompleted && ` ‚Ä¢ Completed ${formatDateTime(attempt.completed_at)}`}
                                  </p>
                                </div>
                              </div>
                              <div className="flex items-center gap-2">
                                <span className="text-sm text-muted-foreground">{answerCount} answers</span>
                                <Button size="sm" onClick={() => openAttemptModal(attempt)}>
                                  View
                                </Button>
                                <Button
                                  size="sm"
                                  variant="ghost"
                                  onClick={() => requestAttemptDeletion(attempt)}
                                >
                                  <svg className="h-4 w-4 text-destructive" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                  </svg>
                                </Button>
                              </div>
                            </div>
                          </CardContent>
                        </Card>
                      );
                    })}
                  </div>
                )}
              </div>
            )}
          </div>

          {/* Quick Switch Sidebar */}
          {!isLoadingQuizzes && quizzes.length > 1 && (
            <Card className="mt-8">
              <CardHeader>
                <CardTitle className="text-base">Switch Quiz</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex flex-wrap gap-2">
                  {quizzes.slice(0, 5).map((item) => (
                    <Button
                      key={item.id}
                      variant={quizIdNumber === item.id ? 'default' : 'outline'}
                      size="sm"
                      to={`/quizzes/${item.id}`}
                    >
                      {item.title}
                    </Button>
                  ))}
                  {quizzes.length > 5 && (
                    <Button variant="outline" size="sm" to="/dashboard">
                      View all
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      )}
      <Modal
        open={Boolean(selectedAttempt)}
        onOpenChange={(open) => {
          if (!open) {
            closeAttemptModal();
          }
        }}
        title="Student attempt"
        description="View the answers recorded for every slot."
      >
        {selectedAttempt ? (
          <div className="space-y-4">
            <div className="rounded-md bg-muted/50 p-3 text-sm">
              <p>
                Attempt:{' '}
                <span className="font-semibold">
                  {selectedAttempt.student_identifier || 'Unknown student'}
                </span>
              </p>
              <p className="text-muted-foreground">
                Started {formatDateTime(selectedAttempt.started_at)}
                {selectedAttempt.completed_at ? ` ¬∑ Completed ${formatDateTime(selectedAttempt.completed_at)}` : ' ¬∑ In progress'}
              </p>
            </div>
            <div className="space-y-4">
              {(selectedAttempt.attempt_slots || []).map((slot) => (
                <div key={slot.id} className="rounded-md border bg-background p-3">
                  <p className="text-sm font-semibold">
                    {slot.slot_label} ¬∑ {slot.problem_display_label}
                  </p>
                  <p className="text-xs text-muted-foreground">{slot.problem_statement}</p>
                  <div className="mt-2 rounded-md bg-muted/50 p-3 text-sm">
                    {renderAttemptAnswer(slot)}
                  </div>
                </div>
              ))}
            </div>
            <div className="flex justify-end gap-3">
              <Button variant="outline" onClick={closeAttemptModal}>
                Close
              </Button>
              <Button
                variant="destructive"
                onClick={() => {
                  if (selectedAttempt) {
                    requestAttemptDeletion(selectedAttempt);
                  }
                  closeAttemptModal();
                }}
              >
                Delete attempt
              </Button>
            </div>
          </div>
        ) : (
          <p className="text-sm text-muted-foreground">Loading attempt details‚Ä¶</p>
        )}
      </Modal>
      <Modal
        open={Boolean(activeSlot)}
        onOpenChange={(open) => {
          if (!open) {
            closeSlotDetailModal();
          }
        }}
        title="Manage slot"
        description="Adjust the label, bank, response type, and selected problems."
      >
        {activeSlot ? (
          <form
            className="space-y-5"
            onSubmit={(event) => {
              event.preventDefault();
              handleSaveSlot(activeSlot);
            }}
          >
            <div className="space-y-2">
              <Label htmlFor="detail-slot-label">Label</Label>
              <Input
                id="detail-slot-label"
                value={activeSlot.label}
                onChange={(event) => handleSlotChange(activeSlot.id, 'label', event.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="detail-slot-bank">Problem bank</Label>
              <select
                id="detail-slot-bank"
                value={activeSlot.problem_bank ?? ''}
                onChange={(event) => handleSlotChange(activeSlot.id, 'problem_bank', event.target.value)}
                className="h-10 w-full rounded-md border px-3 text-sm"
                disabled={isLoadingBanks || !banks.length}
              >
                <option value="" disabled>
                  Select a bank
                </option>
                {banks.map((bank) => (
                  <option key={bank.id} value={bank.id}>
                    {bank.name}
                  </option>
                ))}
              </select>
              <p className="text-xs text-muted-foreground">
                Switching banks clears the selected slot problems. Save after making a change.
              </p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="detail-slot-response">Response type</Label>
              <select
                id="detail-slot-response"
                value={activeSlot.response_type || 'open_text'}
                onChange={(event) => handleSlotChange(activeSlot.id, 'response_type', event.target.value)}
                className="h-10 w-full rounded-md border px-3 text-sm"
              >
                {RESPONSE_TYPE_OPTIONS.map((option) => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
              <p className="text-xs text-muted-foreground">Choose how students will respond in this slot.</p>
            </div>
            {slotError && <p className="text-sm text-destructive">{slotError}</p>}
            <div className="space-y-2">
              <p className="font-semibold">Eligible problems</p>
              {renderSlotProblems(activeSlot)}
            </div>
            <div className="flex justify-end gap-3">
              <Button type="button" variant="outline" onClick={closeSlotDetailModal}>
                Close
              </Button>
              <Button type="submit" variant="secondary" disabled={savingSlotId === activeSlot.id}>
                {savingSlotId === activeSlot.id ? 'Saving‚Ä¶' : 'Save slot'}
              </Button>
            </div>
          </form>
        ) : (
          <p className="text-sm text-muted-foreground">Loading slot details‚Ä¶</p>
        )}
      </Modal>
      <Modal
        open={Boolean(attemptToDelete)}
        onOpenChange={(open) => {
          if (!open) {
            closeAttemptDeleteModal();
          }
        }}
        title="Delete attempt"
        description="Are you sure you want to delete this attempt? This will remove the answers for every slot."
      >
        <div className="space-y-4">
          <div className="rounded-md bg-muted/50 p-3 text-sm">
            <p>
              Attempt:{' '}
              <span className="font-semibold">
                {attemptToDelete?.student_identifier || 'Unknown student'}
              </span>
            </p>
            <p className="text-muted-foreground">
              Started {attemptToDelete ? formatDateTime(attemptToDelete.started_at) : '‚Äî'}
            </p>
          </div>
          <p className="text-sm text-muted-foreground">
            This action cannot be undone and will delete all answers recorded for each problem slot in this attempt.
          </p>
          <div className="flex justify-end gap-3">
            <Button variant="outline" onClick={closeAttemptDeleteModal} disabled={isDeletingAttempt}>
              Cancel
            </Button>
            <Button variant="destructive" onClick={handleDeleteAttempt} disabled={isDeletingAttempt}>
              {isDeletingAttempt ? 'Deleting‚Ä¶' : 'Delete attempt'}
            </Button>
          </div>
        </div>
      </Modal>
      {isSlotModalOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-background/80 px-4 backdrop-blur-sm" onClick={closeSlotModal}>
          <div
            className="w-full max-w-lg rounded-2xl border bg-background p-6 shadow-2xl"
            onClick={(event) => event.stopPropagation()}
          >
            <div className="mb-4 flex items-center justify-between gap-4">
              <div>
                <h3 className="text-lg font-semibold">Add slot</h3>
                <p className="text-sm text-muted-foreground">Name the slot and choose which problem bank feeds it.</p>
              </div>
              <button type="button" className="text-sm text-muted-foreground hover:text-foreground" onClick={closeSlotModal}>
                Close
              </button>
            </div>
            <form className="space-y-5" onSubmit={handleCreateSlot}>
              <div className="space-y-2">
                <Label htmlFor="modal-slot-label">Label</Label>
                <Input
                  id="modal-slot-label"
                  name="label"
                  value={slotForm.label}
                  onChange={handleSlotFormChange}
                  placeholder="Intro problem"
                  autoFocus
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="modal-slot-bank">Problem bank</Label>
                <select
                  id="modal-slot-bank"
                  name="problem_bank"
                  value={slotForm.problem_bank}
                  onChange={handleSlotFormChange}
                  className="h-10 w-full rounded-md border px-3 text-sm"
                  disabled={isLoadingBanks || !banks.length}
                >
                  <option value="" disabled>
                    Select a bank
                  </option>
                  {banks.map((bank) => (
                    <option key={bank.id} value={bank.id}>
                      {bank.name}
                    </option>
                  ))}
                </select>
                {!isLoadingBanks && !banks.length && (
                  <p className="text-xs text-muted-foreground">Create a problem bank before adding slots.</p>
                )}
              </div>
              <div className="space-y-2">
                <Label htmlFor="modal-slot-response">Response type</Label>
                <select
                  id="modal-slot-response"
                  name="response_type"
                  value={slotForm.response_type}
                  onChange={handleSlotFormChange}
                  className="h-10 w-full rounded-md border px-3 text-sm"
                >
                  {RESPONSE_TYPE_OPTIONS.map((option) => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              </div>
              {slotFormError && <p className="text-sm text-destructive">{slotFormError}</p>}
              <div className="flex justify-end gap-3">
                <Button type="button" variant="outline" onClick={closeSlotModal}>
                  Cancel
                </Button>
                <Button type="submit" disabled={!canCreateSlot || isCreatingSlot}>
                  {isCreatingSlot ? 'Adding‚Ä¶' : 'Add slot'}
                </Button>
              </div>
            </form>
          </div>
        </div>
      )}
    </AppShell>
  );
};

export default QuizEditorPage;
